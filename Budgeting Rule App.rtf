{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red77\green80\blue85;\red236\green241\blue247;\red0\green0\blue0;
\red111\green14\blue195;\red24\green112\blue43;\red107\green0\blue1;\red164\green69\blue11;}
{\*\expandedcolortbl;;\cssrgb\c37255\c38824\c40784;\cssrgb\c94118\c95686\c97647;\cssrgb\c0\c0\c0;
\cssrgb\c51765\c18824\c80784;\cssrgb\c9412\c50196\c21961;\cssrgb\c50196\c0\c0;\cssrgb\c70980\c34902\c3137;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Budgeting Rule App\
\
\pard\pardeftab720\partightenfactor0

\f1\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 # app.py\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 import\cf0 \strokec4  os\cb1 \
\cf5 \cb3 \strokec5 import\cf0 \strokec4  io\cb1 \
\cf5 \cb3 \strokec5 import\cf0 \strokec4  json\cb1 \
\cf5 \cb3 \strokec5 import\cf0 \strokec4  csv\cb1 \
\cf5 \cb3 \strokec5 from\cf0 \strokec4  flask \cf5 \strokec5 import\cf0 \strokec4  Flask, request, jsonify, render_template, Response\cb1 \
\cf5 \cb3 \strokec5 from\cf0 \strokec4  dotenv \cf5 \strokec5 import\cf0 \strokec4  load_dotenv\cb1 \
\cf5 \cb3 \strokec5 import\cf0 \strokec4  pandas \cf5 \strokec5 as\cf0 \strokec4  pd\cb1 \
\cf5 \cb3 \strokec5 from\cf0 \strokec4  datetime \cf5 \strokec5 import\cf0 \strokec4  datetime, timedelta \cf2 \strokec2 # Added timedelta\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 # V2 modules\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 from\cf0 \strokec4  database \cf5 \strokec5 import\cf0 \strokec4  (\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     initialize_database,\cb1 \
\cb3     get_db_connection,\cb1 \
\cb3     add_transactions_df,\cb1 \
\cb3     apply_v1_compat_migrations,\cb1 \
\cb3     normalize_amount_signs,\cb1 \
\cb3     get_all_budgets, \cf2 \strokec2 # NEW\cf0 \cb1 \strokec4 \
\cb3     update_budget,   \cf2 \strokec2 # NEW\cf0 \cb1 \strokec4 \
\cb3     estimate_budgets_from_history \cf2 \strokec2 # NEW\cf0 \cb1 \strokec4 \
\cb3 )\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 from\cf0 \strokec4  parser \cf5 \strokec5 import\cf0 \strokec4  intelligent_parser\cb1 \
\cf5 \cb3 \strokec5 from\cf0 \strokec4  ai_categorizer \cf5 \strokec5 import\cf0 \strokec4  categorize_transactions_with_ai, openai_client\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 # --- App Initialization ---\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 load_dotenv()\cb1 \
\cb3 app = Flask(\cf5 \strokec5 __name__\cf0 \strokec4 )\cb1 \
\cb3 DATABASE = \cf6 \strokec6 'finance.db'\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 # --- API Routes ---\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 @app\cf0 \strokec4 .route(\cf6 \strokec6 '/api/accounts'\cf0 \strokec4 , methods=[\cf6 \strokec6 'GET'\cf0 \strokec4 , \cf6 \strokec6 'POST'\cf0 \strokec4 ])\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 def\cf0 \strokec4  handle_accounts():\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     conn = get_db_connection()\cb1 \
\cb3     \cf5 \strokec5 if\cf0 \strokec4  request.method == \cf6 \strokec6 'POST'\cf0 \strokec4 :\cb1 \
\cb3         data = request.get_json()\cb1 \
\cb3         name = data.get(\cf6 \strokec6 'name'\cf0 \strokec4 )\cb1 \
\cb3         \cf5 \strokec5 if\cf0 \strokec4  \cf5 \strokec5 not\cf0 \strokec4  name:\cb1 \
\cb3             conn.close()\cb1 \
\cb3             \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf6 \strokec6 "Account name is required."\cf0 \strokec4 \}), \cf8 \strokec8 400\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 try\cf0 \strokec4 :\cb1 \
\cb3             cursor = conn.execute(\cf6 \strokec6 'INSERT INTO accounts (name) VALUES (?)'\cf0 \strokec4 , (name,))\cb1 \
\cb3             conn.commit()\cb1 \
\cb3             \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "id"\cf0 \strokec4 : cursor.lastrowid, \cf6 \strokec6 "name"\cf0 \strokec4 : name\}), \cf8 \strokec8 201\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 except\cf0 \strokec4  Exception \cf5 \strokec5 as\cf0 \strokec4  e:\cb1 \
\cb3             \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf5 \strokec5 str\cf0 \strokec4 (e)\}), \cf8 \strokec8 409\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 finally\cf0 \strokec4 :\cb1 \
\cb3             conn.close()\cb1 \
\
\cb3     \cf2 \strokec2 # GET\cf0 \cb1 \strokec4 \
\cb3     accounts = conn.execute(\cf6 \strokec6 'SELECT * FROM accounts ORDER BY name'\cf0 \strokec4 ).fetchall()\cb1 \
\cb3     conn.close()\cb1 \
\cb3     \cf5 \strokec5 return\cf0 \strokec4  jsonify([\cf5 \strokec5 dict\cf0 \strokec4 (row) \cf5 \strokec5 for\cf0 \strokec4  row \cf5 \strokec5 in\cf0 \strokec4  accounts])\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 @app\cf0 \strokec4 .route(\cf6 \strokec6 '/api/transactions'\cf0 \strokec4 , methods=[\cf6 \strokec6 'GET'\cf0 \strokec4 ])\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 def\cf0 \strokec4  get_transactions():\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf6 \strokec6 """\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6     V2 + enhancement:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     - supports optional ?account_id=\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     - supports optional ?start_date= & ?end_date=\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     - adds 'flow' field: 'debit' if amount < 0 else 'credit'\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     """\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     conn = get_db_connection()\cb1 \
\cb3     account_id = request.args.get(\cf6 \strokec6 'account_id'\cf0 \strokec4 )\cb1 \
\cb3     start_date = request.args.get(\cf6 \strokec6 'start_date'\cf0 \strokec4 )\cb1 \
\cb3     end_date = request.args.get(\cf6 \strokec6 'end_date'\cf0 \strokec4 )\cb1 \
\cb3     \cb1 \
\cb3     params = []\cb1 \
\cb3     \cb1 \
\cb3     base = (\cb1 \
\cb3         \cf6 \strokec6 "SELECT t.*, a.name as account_name, "\cf0 \cb1 \strokec4 \
\cb3         \cf6 \strokec6 "CASE WHEN t.amount < 0 THEN 'debit' ELSE 'credit' END AS flow "\cf0 \cb1 \strokec4 \
\cb3         \cf6 \strokec6 "FROM transactions t JOIN accounts a ON t.account_id = a.id"\cf0 \cb1 \strokec4 \
\cb3     )\cb1 \
\cb3     \cb1 \
\cb3     \cf2 \strokec2 # Build WHERE clauses dynamically\cf0 \cb1 \strokec4 \
\cb3     where_clauses = []\cb1 \
\cb3     \cf5 \strokec5 if\cf0 \strokec4  account_id:\cb1 \
\cb3         where_clauses.append(\cf6 \strokec6 "t.account_id = ?"\cf0 \strokec4 )\cb1 \
\cb3         params.append(account_id)\cb1 \
\cb3     \cf5 \strokec5 if\cf0 \strokec4  start_date:\cb1 \
\cb3         where_clauses.append(\cf6 \strokec6 "t.transaction_date >= ?"\cf0 \strokec4 )\cb1 \
\cb3         params.append(start_date)\cb1 \
\cb3     \cf5 \strokec5 if\cf0 \strokec4  end_date:\cb1 \
\cb3         where_clauses.append(\cf6 \strokec6 "t.transaction_date <= ?"\cf0 \strokec4 )\cb1 \
\cb3         params.append(end_date)\cb1 \
\cb3         \cb1 \
\cb3     where_sql = \cf6 \strokec6 ""\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 if\cf0 \strokec4  where_clauses:\cb1 \
\cb3         where_sql = \cf6 \strokec6 " WHERE "\cf0 \strokec4  + \cf6 \strokec6 " AND "\cf0 \strokec4 .join(where_clauses)\cb1 \
\
\cb3     order = \cf6 \strokec6 " ORDER BY t.transaction_date DESC, t.id DESC"\cf0 \cb1 \strokec4 \
\cb3     \cb1 \
\cb3     \cf2 \strokec2 # Execute query with dynamic WHERE clause and parameters\cf0 \cb1 \strokec4 \
\cb3     rows = conn.execute(base + where_sql + order, \cf5 \strokec5 tuple\cf0 \strokec4 (params)).fetchall()\cb1 \
\cb3     conn.close()\cb1 \
\cb3     \cf5 \strokec5 return\cf0 \strokec4  jsonify([\cf5 \strokec5 dict\cf0 \strokec4 (r) \cf5 \strokec5 for\cf0 \strokec4  r \cf5 \strokec5 in\cf0 \strokec4  rows])\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 @app\cf0 \strokec4 .route(\cf6 \strokec6 '/api/summary'\cf0 \strokec4 , methods=[\cf6 \strokec6 'GET'\cf0 \strokec4 ])\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 def\cf0 \strokec4  get_summary():\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf6 \strokec6 """Expenses exclude card payments; payments are 'Card Payment' only."""\cf0 \cb1 \strokec4 \
\cb3     conn = get_db_connection()\cb1 \
\cb3     income = conn.execute(\cb1 \
\cb3         \cf6 \strokec6 "SELECT SUM(amount) as total FROM transactions WHERE category = 'Income'"\cf0 \cb1 \strokec4 \
\cb3     ).fetchone()[\cf6 \strokec6 'total'\cf0 \strokec4 ] \cf5 \strokec5 or\cf0 \strokec4  \cf8 \strokec8 0\cf0 \cb1 \strokec4 \
\cb3     payments = conn.execute(\cb1 \
\cb3         \cf6 \strokec6 "SELECT SUM(amount) as total FROM transactions WHERE category = 'Card Payment'"\cf0 \cb1 \strokec4 \
\cb3     ).fetchone()[\cf6 \strokec6 'total'\cf0 \strokec4 ] \cf5 \strokec5 or\cf0 \strokec4  \cf8 \strokec8 0\cf0 \cb1 \strokec4 \
\cb3     expenses = conn.execute(\cb1 \
\cb3         \cf6 \strokec6 "SELECT SUM(amount) as total FROM transactions WHERE amount < 0 AND category NOT IN ('Card Payment')"\cf0 \cb1 \strokec4 \
\cb3     ).fetchone()[\cf6 \strokec6 'total'\cf0 \strokec4 ] \cf5 \strokec5 or\cf0 \strokec4  \cf8 \strokec8 0\cf0 \cb1 \strokec4 \
\cb3     conn.close()\cb1 \
\cb3     \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "income"\cf0 \strokec4 : income, \cf6 \strokec6 "expenses"\cf0 \strokec4 : expenses, \cf6 \strokec6 "payments"\cf0 \strokec4 : payments\})\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 @app\cf0 \strokec4 .route(\cf6 \strokec6 '/api/upload'\cf0 \strokec4 , methods=[\cf6 \strokec6 'POST'\cf0 \strokec4 ])\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 def\cf0 \strokec4  upload_csv():\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf5 \strokec5 if\cf0 \strokec4  \cf6 \strokec6 'file'\cf0 \strokec4  \cf5 \strokec5 not\cf0 \strokec4  \cf5 \strokec5 in\cf0 \strokec4  request.files \cf5 \strokec5 or\cf0 \strokec4  \cf6 \strokec6 'account_id'\cf0 \strokec4  \cf5 \strokec5 not\cf0 \strokec4  \cf5 \strokec5 in\cf0 \strokec4  request.form:\cb1 \
\cb3         \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf6 \strokec6 "Missing file or account_id."\cf0 \strokec4 \}), \cf8 \strokec8 400\cf0 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 file\cf0 \strokec4  = request.files[\cf6 \strokec6 'file'\cf0 \strokec4 ]\cb1 \
\cb3     account_id = request.form.get(\cf6 \strokec6 'account_id'\cf0 \strokec4 )\cb1 \
\
\cb3     conn = get_db_connection()\cb1 \
\cb3     account = conn.execute(\cf6 \strokec6 'SELECT name FROM accounts WHERE id = ?'\cf0 \strokec4 , (account_id,)).fetchone()\cb1 \
\cb3     conn.close()\cb1 \
\cb3     \cf5 \strokec5 if\cf0 \strokec4  \cf5 \strokec5 not\cf0 \strokec4  account:\cb1 \
\cb3         \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf6 \strokec6 "Account not found."\cf0 \strokec4 \}), \cf8 \strokec8 404\cf0 \cb1 \strokec4 \
\
\cb3     file_stream = io.BytesIO(\cf5 \strokec5 file\cf0 \strokec4 .read())\cb1 \
\cb3     df = intelligent_parser(file_stream)\cb1 \
\
\cb3     \cf5 \strokec5 if\cf0 \strokec4  df \cf5 \strokec5 is\cf0 \strokec4  \cf5 \strokec5 None\cf0 \strokec4  \cf5 \strokec5 or\cf0 \strokec4  df.empty:\cb1 \
\cb3         \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf6 \strokec6 "Could not parse the uploaded file."\cf0 \strokec4 \}), \cf8 \strokec8 400\cf0 \cb1 \strokec4 \
\
\cb3     added, skipped = add_transactions_df(df, account[\cf6 \strokec6 'name'\cf0 \strokec4 ])\cb1 \
\
\cb3     \cf5 \strokec5 from\cf0 \strokec4  database \cf5 \strokec5 import\cf0 \strokec4  normalize_amount_signs  \cb1 \
\cb3     normalize_amount_signs()                     \cb1 \
\
\cb3     \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "message"\cf0 \strokec4 : \cf6 \strokec6 f"Successfully imported \cf0 \strokec4 \{added\}\cf6 \strokec6  new transactions. Skipped \cf0 \strokec4 \{skipped\}\cf6 \strokec6  duplicates."\cf0 \strokec4 \})\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 @app\cf0 \strokec4 .route(\cf6 \strokec6 '/api/update-category'\cf0 \strokec4 , methods=[\cf6 \strokec6 'POST'\cf0 \strokec4 ])\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 def\cf0 \strokec4  update_category():\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     data = request.get_json()\cb1 \
\cb3     \cf5 \strokec5 if\cf0 \strokec4  \cf5 \strokec5 not\cf0 \strokec4  \cf5 \strokec5 all\cf0 \strokec4 (k \cf5 \strokec5 in\cf0 \strokec4  data \cf5 \strokec5 for\cf0 \strokec4  k \cf5 \strokec5 in\cf0 \strokec4  (\cf6 \strokec6 "transaction_id"\cf0 \strokec4 , \cf6 \strokec6 "new_category"\cf0 \strokec4 , \cf6 \strokec6 "description"\cf0 \strokec4 )):\cb1 \
\cb3         \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf6 \strokec6 "Missing data for category update."\cf0 \strokec4 \}), \cf8 \strokec8 400\cf0 \cb1 \strokec4 \
\
\cb3     conn = get_db_connection()\cb1 \
\cb3     conn.execute(\cf6 \strokec6 'UPDATE transactions SET category = ? WHERE id = ?'\cf0 \strokec4 , (data[\cf6 \strokec6 'new_category'\cf0 \strokec4 ], data[\cf6 \strokec6 'transaction_id'\cf0 \strokec4 ]))\cb1 \
\cb3     conn.execute(\cb1 \
\cb3         \cf6 \strokec6 'INSERT OR REPLACE INTO category_rules (merchant_pattern, category) VALUES (?, ?)'\cf0 \strokec4 ,\cb1 \
\cb3         (data[\cf6 \strokec6 'description'\cf0 \strokec4 ].lower(), data[\cf6 \strokec6 'new_category'\cf0 \strokec4 ])\cb1 \
\cb3     )\cb1 \
\cb3     conn.commit()\cb1 \
\cb3     conn.close()\cb1 \
\cb3     \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "message"\cf0 \strokec4 : \cf6 \strokec6 "Transaction and rule updated successfully."\cf0 \strokec4 \})\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 @app\cf0 \strokec4 .route(\cf6 \strokec6 '/api/ai-categorize'\cf0 \strokec4 , methods=[\cf6 \strokec6 'POST'\cf0 \strokec4 ])\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 def\cf0 \strokec4  ai_categorize_route():\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     result = categorize_transactions_with_ai()\cb1 \
\cb3     \cf5 \strokec5 return\cf0 \strokec4  jsonify(result)\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 @app\cf0 \strokec4 .route(\cf6 \strokec6 '/api/ai-financial-report'\cf0 \strokec4 , methods=[\cf6 \strokec6 'POST'\cf0 \strokec4 ])\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 def\cf0 \strokec4  ai_financial_report():\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf5 \strokec5 if\cf0 \strokec4  \cf5 \strokec5 not\cf0 \strokec4  openai_client:\cb1 \
\cb3         \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf6 \strokec6 "OpenAI client not initialized."\cf0 \strokec4 \}), \cf8 \strokec8 500\cf0 \cb1 \strokec4 \
\
\cb3     conn = get_db_connection()\cb1 \
\cb3     transactions = conn.execute(\cb1 \
\cb3         \cf6 \strokec6 'SELECT transaction_date as date, cleaned_description, amount, category FROM transactions'\cf0 \cb1 \strokec4 \
\cb3     ).fetchall()\cb1 \
\
\cb3     \cf5 \strokec5 if\cf0 \strokec4  \cf5 \strokec5 not\cf0 \strokec4  transactions:\cb1 \
\cb3         conn.close()\cb1 \
\cb3         \cf5 \strokec5 return\cf0 \strokec4  jsonify(\{\cf6 \strokec6 "error"\cf0 \strokec4 : \cf6 \strokec6 "No transactions available to generate a report."\cf0 \strokec4 \}), \cf8 \strokec8 400\cf0 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 # Compute months covered based on Income transactions (fallback to 1)\cf0 \cb1 \strokec4 \
\cb3     income_rows = [\cf5 \strokec5 dict\cf0 \strokec4 (r) \cf5 \strokec5 for\cf0 \strokec4  r \cf5 \strokec5 in\cf0 \strokec4  transactions \cf5 \strokec5 if\cf0 \strokec4  r[\cf6 \strokec6 'category'\cf0 \strokec4 ] == \cf6 \strokec6 'Income'\cf0 \strokec4 ]\cb1 \
\cb3     months = \cf5 \strokec5 set\cf0 \strokec4 ()\cb1 \
\cb3     total_income = \cf8 \strokec8 0.0\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 from\cf0 \strokec4  datetime \cf5 \strokec5 import\cf0 \strokec4  datetime \cf5 \strokec5 as\cf0 \strokec4  _dt\cb1 \
\cb3     \cf5 \strokec5 for\cf0 \strokec4  r \cf5 \strokec5 in\cf0 \strokec4  income_rows:\cb1 \
\cb3         total_income += \cf5 \strokec5 float\cf0 \strokec4 (r[\cf6 \strokec6 'amount'\cf0 \strokec4 ] \cf5 \strokec5 or\cf0 \strokec4  \cf8 \strokec8 0\cf0 \strokec4 )\cb1 \
\cb3         \cf5 \strokec5 try\cf0 \strokec4 :\cb1 \
\cb3             month_year = _dt.strptime(r[\cf6 \strokec6 'date'\cf0 \strokec4 ], \cf6 \strokec6 '%Y-%m-%d'\cf0 \strokec4 ).strftime(\cf6 \strokec6 '%Y-%m'\cf0 \strokec4 )\cb1 \
\cb3             months.add(month_year)\cb1 \
\cb3         \cf5 \strokec5 except\cf0 \strokec4  Exception:\cb1 \
\cb3             \cf5 \strokec5 pass\cf0 \cb1 \strokec4 \
\cb3     num_months = \cf5 \strokec5 len\cf0 \strokec4 (months) \cf5 \strokec5 if\cf0 \strokec4  months \cf5 \strokec5 else\cf0 \strokec4  \cf8 \strokec8 1\cf0 \cb1 \strokec4 \
\cb3     avg_monthly_income = (total_income / num_months) \cf5 \strokec5 if\cf0 \strokec4  num_months \cf5 \strokec5 else\cf0 \strokec4  \cf8 \strokec8 0.0\cf0 \cb1 \strokec4 \
\
\cb3     transaction_summary = [\cf5 \strokec5 dict\cf0 \strokec4 (row) \cf5 \strokec5 for\cf0 \strokec4  row \cf5 \strokec5 in\cf0 \strokec4  transactions]\cb1 \
\cb3     conn.close()\cb1 \
\
\cb3     prompt = \cf6 \strokec6 f"""\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6     You are a professional financial advisor. Your client has provided their transaction history.\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     Your task \cf5 \strokec5 is\cf0 \strokec4  to provide a detailed financial analysis \cf5 \strokec5 and\cf0 \strokec4  a recommended monthly budget.\cb1 \
\
\cb3     **Client\cf6 \strokec6 's Financial Context:**\cf0 \cb1 \strokec4 \
\cb3     - The data covers a period of \{num_months\} month(s).\cb1 \
\cb3     - The client\cf6 \strokec6 's average monthly income is approximately $\{avg_monthly_income:,.2f\}.\cf0 \cb1 \strokec4 \
\
\cb3     **Your report must include the following three sections:**\cb1 \
\cb3     \cf8 \strokec8 1\cf0 \strokec4 . **Monthly Spending Analysis:** Summarize the client\cf6 \strokec6 's spending for the most recent month; identify top 3-5 categories; flag red flags.\cf0 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 2\cf0 \strokec4 . **Recommended Monthly Budget:** Based on avg monthly income above, propose concrete dollar amounts \cf5 \strokec5 for\cf0 \strokec4  key categories (Housing, Groceries, Transport, Entertainment, Savings, etc.).\cb1 \
\cb3     \cf8 \strokec8 3\cf0 \strokec4 . **Actionable Recommendations:** Provide \cf8 \strokec8 2-3\cf0 \strokec4  concrete steps tied to the analysis (e.g., trim subscriptions, automate savings).\cb1 \
\
\cb3     Format \cf5 \strokec5 as\cf0 \strokec4  Markdown \cf5 \strokec5 with\cf0 \strokec4  clear headings \cf5 \strokec5 and\cf0 \strokec4  bullet points.\cb1 \
\
\cb3     **Transaction Data \cf5 \strokec5 for\cf0 \strokec4  Analysis:**\cb1 \
\cb3     \{json.dumps(transaction_summary, indent=\cf8 \strokec8 2\cf0 \strokec4 )\}\cb1 \
\cb3     \cf6 \strokec6 """\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6     try:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         from ai_categorizer import openai_client as _client\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         response = _client.chat.completions.create(\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             model="gpt-4o",\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             messages=[\{"role": "user", "content": prompt\}]\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         )\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         report_content = response.choices[0].message.content\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         return jsonify(\{"report": report_content\})\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     except Exception as e:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         return jsonify(\{"error": f"An error occurred with the OpenAI API: \{str(e)\}"\}), 500\cf0 \cb1 \strokec4 \
\
\
\cf6 \cb3 \strokec6 @app.route('/api/export', methods=['GET'])\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 def export_transactions():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     """\cf0 \strokec4 Exports \cf5 \strokec5 all\cf0 \strokec4  transactions to a CSV \cf5 \strokec5 file\cf0 \strokec4  \cf5 \strokec5 for\cf0 \strokec4  bulk editing.\cf6 \strokec6 """\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     conn = get_db_connection()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     transactions = conn.execute(\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         """\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3         SELECT\cb1 \
\cb3             t.\cf5 \strokec5 id\cf0 \strokec4 ,\cb1 \
\cb3             t.transaction_date,\cb1 \
\cb3             a.name \cf5 \strokec5 as\cf0 \strokec4  account_name,\cb1 \
\cb3             t.cleaned_description,\cb1 \
\cb3             t.amount,\cb1 \
\cb3             t.category\cb1 \
\cb3         FROM transactions t\cb1 \
\cb3         JOIN accounts a ON t.account_id = a.\cf5 \strokec5 id\cf0 \cb1 \strokec4 \
\cb3         ORDER BY t.transaction_date DESC\cb1 \
\cb3         \cf6 \strokec6 """\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6     ).fetchall()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     conn.close()\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6     # Use an in-memory string buffer\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     output = io.StringIO()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     writer = csv.writer(output)\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6     # Write the header\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     writer.writerow(['transaction_id', 'date', 'account', 'description', 'amount', 'category', 'new_category'])\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6     # Write transaction rows\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     for row in transactions:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         # The 'new_category' is a copy of the current category for the user to edit\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         writer.writerow([row['id'], row['transaction_date'], row['account_name'], row['cleaned_description'], row['amount'], row['category'], row['category']])\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6     # Prepare the response\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     output.seek(0)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     return Response(\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         output,\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         mimetype="text/csv",\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         headers=\{"Content-Disposition": "attachment;filename=transactions_export.csv"\}\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     )\cf0 \cb1 \strokec4 \
\
\
\cf6 \cb3 \strokec6 @app.route('/api/import-corrections', methods=['POST'])\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 def import_corrections():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     """\cf0 \strokec4 Imports a CSV of corrections \cf5 \strokec5 and\cf0 \strokec4  updates categories where they have changed.\cf6 \strokec6 """\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     if 'file' not in request.files:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         return jsonify(\{"error": "Missing file for corrections."\}), 400\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6     file = request.files['file']\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     try:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         df = pd.read_csv(file, na_filter=False)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         # Ensure required columns exist\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         required_cols = ['transaction_id', 'description', 'category', 'new_category']\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         if not all(col in df.columns for col in required_cols):\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             return jsonify(\{"error": f"Invalid CSV. Missing one of the required columns: \{', '.join(required_cols)\}"\}), 400\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6         changed_rows = df[df['category'] != df['new_category']]\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6         if (changed_rows['new_category'] == '').any():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             return jsonify(\{"error": "There are blank entries. Please correct and reload."\}), 400\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6         conn = get_db_connection()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         updated_count = 0\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         for _, row in changed_rows.iterrows():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             transaction_id = int(row['transaction_id'])\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             new_category = row['new_category']\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             description = str(row['description'])\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6             # 1. Update the transaction's category\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             conn.execute('UPDATE transactions SET category = ? WHERE id = ?', (new_category, transaction_id))\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6             # 2. Update the learning rule (same logic as /api/update-category)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             if description:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6                 conn.execute(\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6                     'INSERT OR REPLACE INTO category_rules (merchant_pattern, category) VALUES (?, ?)',\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6                     (description.lower(), new_category)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6                 )\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             updated_count += 1\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6         conn.commit()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         conn.close()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         return jsonify(\{"message": f"Successfully updated \{updated_count\} transactions."\})\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6     except Exception as e:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         return jsonify(\{"error": f"An error occurred during import: \{str(e)\}"\}), 500\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6 # START: NEW BUDGET ROUTES\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 @app.route('/api/budgets', methods=['GET', 'POST'])\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 def handle_budgets():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     if request.method == 'POST':\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         data = request.get_json()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         if not data or 'category' not in data or 'amount' not in data:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             return jsonify(\{"error": "Missing category or amount"\}), 400\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         try:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             amount = float(data['amount'])\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             update_budget(data['category'], amount)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             return jsonify(\{"message": "Budget updated successfully."\})\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         except (ValueError, TypeError):\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             return jsonify(\{"error": "Invalid amount specified."\}), 400\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     \cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     # GET request\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     budgets = get_all_budgets()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     return jsonify(budgets)\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6 @app.route('/api/estimate-budgets', methods=['POST'])\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 def estimate_budgets_route():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     estimated_budgets = estimate_budgets_from_history()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     # Save these estimates to the database\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     for category, amount in estimated_budgets.items():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         update_budget(category, amount)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     return jsonify(\{\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         "message": f"Successfully estimated and saved budgets for \{len(estimated_budgets)\} categories.",\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         "budgets": estimated_budgets\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     \})\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 # END: NEW BUDGET ROUTES\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6 # --- Frontend Route ---\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 @app.route('/')\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 def index():\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     return render_template('index.html')\cf0 \cb1 \strokec4 \
\
\
\cf6 \cb3 \strokec6 # --- Main Execution ---\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 if __name__ == '__main__':\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     if not os.path.exists(DATABASE):\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         initialize_database()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     else:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         apply_v1_compat_migrations()\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6     normalize_amount_signs()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     app.run(debug=True, port=5002)\cf0 \cb1 \strokec4 \
}